<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Panel Editor – {{ project.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/ui.build.css?v=1" />
  <style>
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;margin:0}
    /* Fallback layout so page works even if certain Tailwind utilities are missing */
    .layout{display:grid;grid-template-columns:400px 1fr;gap:0;min-height:100vh}
    .sidebar{background:#0b1220;border-right:1px solid #1e293b;padding:12px;overflow-y:auto;max-height:100vh;position:sticky;top:0}
    .main{padding:16px;overflow:auto;padding-bottom:96px}
  .panels-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
    .bottombar{position:fixed;left:400px;right:0;bottom:0;background:#0b1220;border-top:1px solid #1e293b;padding:8px 12px;z-index:50}
    .card-pad{padding:12px}
    .page-item-checkbox{width:16px;height:16px;cursor:pointer}
  </style>
  <script id="project-data" type="application/json">{{ project|tojson|safe }}</script>
</head>
<body>
  <div class="layout">
    <aside class="card sidebar">
      <div class="topbar">
        <div class="font-extrabold">Pages</div>
        <a class="btn secondary" href="/">Home</a>
      </div>
      <div id="pagesList" class="flex flex-col gap-2"></div>
    </aside>
    <main class="main">
      <div class="card">
        <div class="card-pad">
          <div class="topbar">
            <div class="row">
              <button id="prevPage" class="btn secondary">Prev</button>
              <div id="pageTitle" class="font-extrabold">Page</div>
              <button id="nextPage" class="btn secondary">Next</button>
            </div>
            <div class="row">
              <button id="createPanelsBtn" class="btn secondary" style="margin-right:8px">Create Panels</button>
              <a id="backToEditor" class="btn secondary">Back</a>
              <a id="openVideoEditor" class="btn">Open Video Editor</a>
            </div>
          </div>
        </div>
      </div>
      <div id="panelsRoot" class="panels-grid" style="margin-top:12px"></div>
      <div class="card bottombar">
        <div class="row" style="flex-wrap:wrap;justify-content:space-between;gap:8px">
          <div class="row" style="gap:8px">
            <button id="deleteSelectedPages" class="btn" style="background:#ef4444;border-color:#ef4444" disabled>
              <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-right:4px">
                <path d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
              </svg>
              Delete Pages
            </button>
            <button id="reorderPagesBtn" class="btn secondary">
              <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-right:4px">
                <path d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
              </svg>
              Reorder Pages
            </button>
            <select id="globalEffect" class="select">
              <option value="none">Effect: None</option>
              <option value="kenburns">Effect: Ken Burns</option>
              <option value="zoom_in">Effect: Zoom In</option>
              <option value="zoom_out">Effect: Zoom Out</option>
              <option value="pan_left">Effect: Pan Left</option>
              <option value="pan_right">Effect: Pan Right</option>
            </select>
            <select id="globalTransition" class="select">
              <option value="slide_book">Transition: Slide (Book)</option>
              <option value="fade">Transition: Fade</option>
              <option value="cut">Transition: Cut</option>
              <option value="slide_left">Transition: Slide Left</option>
              <option value="slide_right">Transition: Slide Right</option>
            </select>
            <button id="applyGlobalConfig" class="btn">Apply</button>
          </div>
          <div class="row" style="gap:8px; align-items:center">
            <div class="row" style="gap:8px; align-items:center; border-right:1px solid #1e293b; padding-right:12px; margin-right:4px">
               <div id="modelStatus" class="muted" style="font-size:12px">Model: Checking...</div>
               <button id="loadModelBtn" class="btn secondary" style="display:none">Load Model</button>
            </div>
            <button id="synthAll" class="btn secondary">Synthesize All</button>
            <div id="synthProgress" class="muted" style="min-width:260px"></div>
            <div id="synthBarWrap" style="flex:1; max-width:420px;display:none">
              <div style="height:8px;background:#1e293b;border-radius:6px;overflow:hidden">
                <div id="synthBar" style="height:100%;width:0%;background:#3b82f6;transition:width .2s ease"></div>
              </div>
            </div>
            <button id="saveAll" class="btn">Save All</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
  const project = JSON.parse(document.getElementById('project-data')?.textContent || '{}');
    let pages = [];
    let currentIndex = 0;
    let selectedPages = new Set(); // Track selected pages for deletion

    async function fetchSummary(){
      const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}`, { headers:{'ngrok-skip-browser-warning':'true'} });
      if(!r.ok) throw new Error('Failed to load project');
      const d = await r.json();
      pages = d.pages || [];
      selectedPages.clear(); // Reset selections after refresh
      renderPagesList();
      renderCurrentPage();
    }

    function renderPagesList(){
      const root = document.getElementById('pagesList');
      root.innerHTML = '';
      pages.forEach((pg,i)=>{
        const row = document.createElement('div');
        row.className = 'flex items-center gap-2 p-2 border rounded-md bg-slate-900 ' + (i===currentIndex?' outline outline-2 outline-blue-500':'');
        row.innerHTML = `
          <input type="checkbox" class="page-item-checkbox" data-page-index="${i}" ${selectedPages.has(i) ? 'checked' : ''} onclick="event.stopPropagation()">
          <div class="w-16 h-16 rounded-md bg-black/40 overflow-hidden border flex-shrink-0 cursor-pointer" data-navigate="${i}">
            <img class="w-full h-full object-cover" src="${pg.image_url || ''}">
          </div>
          <div class="flex-1 cursor-pointer" data-navigate="${i}">
            <div class="font-medium">Page ${pg.page_number}</div>
            <div class="muted">${(pg.panels||[]).length} panel(s)</div>
          </div>
        `;
        
        // Handle checkbox changes
        const checkbox = row.querySelector('.page-item-checkbox');
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedPages.add(i);
          } else {
            selectedPages.delete(i);
          }
          updateDeleteButton();
        });
        
        // Handle navigation clicks (image and text)
        row.querySelectorAll('[data-navigate]').forEach(el => {
          el.addEventListener('click', () => { 
            currentIndex = i; 
            renderPagesList(); 
            renderCurrentPage(); 
          });
        });
        
        root.appendChild(row);
      });
    }

    function updateDeleteButton() {
      const btn = document.getElementById('deleteSelectedPages');
      if (btn) {
        btn.textContent = selectedPages.size > 0 ? `Delete ${selectedPages.size} Page(s)` : 'Delete Pages';
        btn.disabled = selectedPages.size === 0;
      }
    }

    function renderCurrentPage(){
      const pg = pages[currentIndex] || pages[0];
      if(!pg) return;
      document.getElementById('pageTitle').textContent = `Page ${pg.page_number}`;
      const root = document.getElementById('panelsRoot');
      root.innerHTML = '';
      // Set global selects to the most common values for this page (or sensible defaults)
      try{
        const ge = document.getElementById('globalEffect');
        const gt = document.getElementById('globalTransition');
        const panels = (pg.panels || []);
        const effs = panels.map(p => (p && p.effect) ? String(p.effect) : 'zoom_in');
        const transs = panels.map(p => (p && p.transition) ? String(p.transition) : 'slide_book');
        const mode = (arr, defVal) => {
          if(!arr || arr.length === 0) return defVal;
          const m = new Map();
          arr.forEach(v => m.set(v, (m.get(v)||0)+1));
          let best = defVal, cnt = -1;
          m.forEach((c, v) => { if(c > cnt){ cnt = c; best = v; } });
          return best;
        };
        if(ge) ge.value = mode(effs, 'zoom_in');
        if(gt) gt.value = mode(transs, 'slide_book');
      }catch(e){ /* ignore */ }
      (pg.panels||[]).forEach(p=>{
        const card = document.createElement('div');
        card.className = 'card overflow-hidden';
        card.innerHTML = `
          ${p.image?`<img class="w-full h-[220px] object-cover" src="${p.image}?t=${Date.now()}" alt="panel">`:`<div class='h-[220px] flex items-center justify-center text-slate-400'>No image</div>`}
          <div class="p-3">
            <div class="flex items-center justify-between mb-2">
              <div class="font-bold">Panel #${p.index}</div>
              <button class="btn secondary" data-delete="${p.index}" style="padding:4px 8px;background:#ef4444;border-color:#ef4444;color:white;font-size:11px" title="Delete this panel">
                <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                  <path d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
              </button>
            </div>
            <textarea class="textarea" data-idx="${p.index}" placeholder="Narration for this panel…">${p.text||''}</textarea>
            <div class="row mt-2">
              <button class="btn secondary" data-save="${p.index}">Save</button>
              <span class="muted">Audio will be generated by "Synthesize All"</span>
            </div>
            <div class="row mt-2">
              <select data-eff="${p.index}" class="select">
                <option value="none" ${p.effect==='none'?'selected':''}>Effect: None</option>
                <option value="kenburns" ${p.effect==='kenburns'?'selected':''}>Effect: Ken Burns</option>
                <option value="zoom_in" ${p.effect==='zoom_in'?'selected':''}>Effect: Zoom In</option>
                <option value="zoom_out" ${p.effect==='zoom_out'?'selected':''}>Effect: Zoom Out</option>
                <option value="pan_left" ${p.effect==='pan_left'?'selected':''}>Effect: Pan Left</option>
                <option value="pan_right" ${p.effect==='pan_right'?'selected':''}>Effect: Pan Right</option>
              </select>
              <select data-trans="${p.index}" class="select">
                <option value="slide_book" ${p.transition==='slide_book'?'selected':''}>Transition: Slide (Book)</option>
                <option value="fade" ${p.transition==='fade'?'selected':''}>Transition: Fade</option>
                <option value="cut" ${p.transition==='cut'?'selected':''}>Transition: Cut</option>
                <option value="slide_left" ${p.transition==='slide_left'?'selected':''}>Slide Left</option>
                <option value="slide_right" ${p.transition==='slide_right'?'selected':''}>Slide Right</option>
              </select>
              <button class="btn secondary" data-savecfg="${p.index}">Save</button>
            </div>
            <div class="row mt-2" style="gap:8px;align-items:center">
              <button class="btn" data-synth="${p.index}">${p.audio ? 'Resynthesize' : 'Synthesize'}</button>
              <div class="muted" style="font-size:12px" data-synth-status="${p.index}"></div>
            </div>
            <div class="audio-slot mt-2" data-audio="${p.index}"></div>
            </div>
          </div>
        `;
        root.appendChild(card);
      });

      // Wire save buttons
      root.querySelectorAll('button[data-save]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const idx = parseInt(btn.getAttribute('data-save'))||1;
          const ta = root.querySelector(`textarea[data-idx="${idx}"]`);
          const text = (ta?.value || '').trim();
          const pn = (pages[currentIndex]||{}).page_number;
          const ok = await savePanelText(pn, idx, text);
          if(ok){ btn.textContent = 'Saved'; setTimeout(()=>btn.textContent='Save', 1000); }
        });
      });

      // Wire delete buttons
      root.querySelectorAll('button[data-delete]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const idx = parseInt(btn.getAttribute('data-delete'))||1;
          const pn = (pages[currentIndex]||{}).page_number;
          if(!confirm(`Delete Panel ${idx}? This will re-number remaining panels.`)) return;
          
          try {
            const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/panel/${encodeURIComponent(pn)}/${encodeURIComponent(idx)}`, {
              method: 'DELETE',
              headers: {'ngrok-skip-browser-warning':'true'}
            });
            if(r.ok) {
              await fetchSummary(); // Reload to show updated panel indices
            } else {
              alert('Failed to delete panel');
            }
          } catch(err) {
            console.error(err);
            alert('Error deleting panel: ' + err.message);
          }
        });
      });


      // Per-panel synth removed; generation is handled by global button

      // Render any existing audio
      (pg.panels||[]).forEach(p=>{ if(p.audio){ renderAudioFor(p.index, p.audio); } });

      // Wire per-panel config save
      root.querySelectorAll('button[data-savecfg]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const idx = parseInt(btn.getAttribute('data-savecfg'))||1;
          const effSel = root.querySelector(`select[data-eff="${idx}"]`);
          const transSel = root.querySelector(`select[data-trans="${idx}"]`);
          const eff = effSel?.value || 'zoom_in';
          const trans = transSel?.value || 'slide_book';
          const pn = (pages[currentIndex]||{}).page_number;
          const ok = await savePanelConfig(pn, idx, eff, trans);
          if(ok){ btn.textContent = 'Saved'; setTimeout(()=>btn.textContent='Save Config', 1000); }
        });
      });

      // Wire per-panel synth buttons
      root.querySelectorAll('button[data-synth]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const idx = parseInt(btn.getAttribute('data-synth'))||1;
          const pn = (pages[currentIndex]||{}).page_number;
          const statusEl = root.querySelector(`[data-synth-status="${idx}"]`);
          let hasAudio = false;
          try{
            btn.disabled = true;
            const original = btn.textContent;
            btn.textContent = 'Synthesizing…';
            if(statusEl) statusEl.textContent = 'Starting...';
            const audioUrl = await synthPanel(project.id, pn, idx);
            if(audioUrl){
              // Save audio URL to server for this panel
              const saved = await savePanelAudio(pn, idx, audioUrl);
              // Update local model
              const pLoc = (pages[currentIndex]||{}).panels?.find(x=>parseInt(x.index)===parseInt(idx));
              if(pLoc) pLoc.audio = audioUrl;
              // Render audio control
              renderAudioFor(idx, audioUrl);
              if(statusEl) statusEl.textContent = 'Done';
              hasAudio = true;
              // Update button text to Resynthesize
              btn.textContent = 'Resynthesize';
            } else {
              if(statusEl) statusEl.textContent = 'Failed';
              alert('Synthesis failed for panel ' + idx);
              // Keep original label (Synthesize or Resynthesize)
              btn.textContent = original;
            }
          }catch(err){
            console.error(err);
            if(statusEl) statusEl.textContent = 'Error';
            alert('Failed to synthesize panel: ' + err.message);
            // restore original label
            try{ btn.textContent = btn.textContent || 'Synthesize'; }catch(e){}
          }finally{
            btn.disabled = false;
            // If we created audio, ensure button shows Resynthesize, otherwise show original
            if(!hasAudio){
              // Determine current state from local model in case it changed
              const pLoc2 = (pages[currentIndex]||{}).panels?.find(x=>parseInt(x.index)===parseInt(idx));
              btn.textContent = (pLoc2 && pLoc2.audio) ? 'Resynthesize' : 'Synthesize';
            }
            setTimeout(()=>{ if(statusEl) statusEl.textContent = ''; }, 2500);
          }
        });
      });
    }

    async function savePanelText(pageNumber, panelIndex, text){
      const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/panel/${encodeURIComponent(pageNumber)}/${encodeURIComponent(panelIndex)}/text`, {
        method:'PUT', headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'},
        body: JSON.stringify({ text })
      });
      return r.ok;
    }

    document.getElementById('prevPage').addEventListener('click', ()=>{
      if(currentIndex>0){ currentIndex--; renderPagesList(); renderCurrentPage(); }
    });
    document.getElementById('nextPage').addEventListener('click', ()=>{
      if(currentIndex<pages.length-1){ currentIndex++; renderPagesList(); renderCurrentPage(); }
    });
    document.getElementById('backToEditor').addEventListener('click', ()=>{
      window.location.href = `/editor/manga-editor/${encodeURIComponent(project.id)}`;
    });
    document.getElementById('openVideoEditor').addEventListener('click', ()=>{
      window.location.href = `/editor/video-editor/${encodeURIComponent(project.id)}`;
    });

    // Create Panels for current page
    document.getElementById('createPanelsBtn').addEventListener('click', async (e)=>{
        const btn = e.currentTarget;
        const pg = pages[currentIndex];
        if(!pg) return;
        
        if(!confirm(`Re-create panels for Page ${pg.page_number}? This will OVERWRITE existing panels and any narration/audio.`)) return;
        
        const orig = btn.textContent;
        btn.textContent = 'Creating...';
        btn.disabled = true;
        
        try{
            const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/panels/create/page/${encodeURIComponent(pg.page_number)}`, {
                method: 'POST',
                headers: {'ngrok-skip-browser-warning':'true'}
            });
            if(r.ok){
                const data = await r.json();
                alert(`Created ${data.created || 0} panels.`);
                await fetchSummary(); // Refresh UI
            }else{
                console.error(r);
                alert('Failed to create panels');
            }
        }catch(err){
            console.error(err);
            alert('Error creating panels: ' + err.message);
        }finally{
            btn.textContent = orig;
            btn.disabled = false;
        }
    });
    
    // Delete selected pages
    document.getElementById('deleteSelectedPages').addEventListener('click', async ()=>{
      if(selectedPages.size === 0) {
        alert('No pages selected');
        return;
      }
      
      const pageNums = Array.from(selectedPages).map(i => pages[i].page_number).sort((a,b) => a-b);
      const message = `Delete ${selectedPages.size} page(s)?\n\nPages: ${pageNums.join(', ')}\n\nThis cannot be undone.`;
      
      if(!confirm(message)) return;
      
      const btn = document.getElementById('deleteSelectedPages');
      const origText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Deleting...';
      
      try {
        let deletedCount = 0;
        // Delete pages one by one
        for(const pageIndex of Array.from(selectedPages).sort((a,b) => b-a)) { // Delete in reverse order
          const pg = pages[pageIndex];
          if(!pg) continue;
          
          const response = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/page/${encodeURIComponent(pg.page_number)}`, {
            method: 'DELETE',
            headers: {'ngrok-skip-browser-warning': 'true'}
          });
          
          if(response.ok) {
            deletedCount++;
          } else {
            const errorData = await response.json().catch(() => ({}));
            console.error(`Failed to delete page ${pg.page_number}:`, errorData.detail);
          }
        }
        
        if(deletedCount > 0) {
          alert(`Successfully deleted ${deletedCount} page(s)`);
          selectedPages.clear();
          await fetchSummary();
          // Reset to first page if current was deleted
          if(currentIndex >= pages.length) {
            currentIndex = Math.max(0, pages.length - 1);
          }
        } else {
          alert('Failed to delete pages');
        }
      } catch(error) {
        console.error('Delete error:', error);
        alert('Failed to delete pages: ' + error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = origText;
      }
    });
    
    // Reorder pages functionality
    document.getElementById('reorderPagesBtn').addEventListener('click', () => {
      showReorderDialog();
    });
    
    function showReorderDialog() {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
      `;
      
      const pagesList = pages.map((pg, idx) => `
        <div style="display:flex;align-items:center;gap:12px;padding:12px;background:#0b1220;border:1px solid #1e293b;border-radius:8px;margin-bottom:8px">
          <div style="display:flex;gap:8px">
            <button class="btn secondary" data-move-up="${idx}" ${idx === 0 ? 'disabled' : ''} style="padding:6px">
              <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M5 15l7-7 7 7"/>
              </svg>
            </button>
            <button class="btn secondary" data-move-down="${idx}" ${idx === pages.length - 1 ? 'disabled' : ''} style="padding:6px">
              <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M19 9l-7 7-7-7"/>
              </svg>
            </button>
          </div>
          <div style="flex:1">
            <div style="font-weight:600;color:#e2e8f0">Page ${pg.page_number}</div>
            <div style="font-size:12px;color:#64748b">${pg.panels?.length || 0} panels</div>
          </div>
          <div style="font-weight:600;color:#8b5cf6;font-size:16px;min-width:40px;text-align:center">→ ${idx + 1}</div>
        </div>
      `).join('');
      
      modal.innerHTML = `
        <div style="background:#0f1729;border:1px solid #1e293b;border-radius:12px;padding:24px;max-width:600px;width:100%;max-height:80vh;overflow-y:auto">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:20px">
            <h3 style="margin:0;font-size:18px;font-weight:700;color:#e2e8f0">Reorder Pages</h3>
            <button id="closeReorderModal" class="btn secondary" style="padding:6px 12px">×</button>
          </div>
          
          <div style="margin-bottom:16px;color:#94a3b8;font-size:13px">
            Use arrows to move pages up/down. Pages will be automatically renumbered sequentially (1, 2, 3...) based on the order shown.
          </div>
          
          <div id="reorderList">
            ${pagesList}
          </div>
          
          <div style="display:flex;gap:12px;justify-content:flex-end;margin-top:20px">
            <button id="cancelReorder" class="btn secondary">Cancel</button>
            <button id="saveReorder" class="btn" style="background:#8b5cf6;border-color:#8b5cf6">Save Order</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Move up button
      modal.querySelectorAll('[data-move-up]').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.getAttribute('data-move-up'));
          if (idx > 0) {
            [pages[idx - 1], pages[idx]] = [pages[idx], pages[idx - 1]];
            modal.remove();
            showReorderDialog();
          }
        });
      });
      
      // Move down button
      modal.querySelectorAll('[data-move-down]').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.getAttribute('data-move-down'));
          if (idx < pages.length - 1) {
            [pages[idx], pages[idx + 1]] = [pages[idx + 1], pages[idx]];
            modal.remove();
            showReorderDialog();
          }
        });
      });
      
      // Close button
      modal.querySelector('#closeReorderModal').addEventListener('click', () => modal.remove());
      modal.querySelector('#cancelReorder').addEventListener('click', () => modal.remove());
      
      // Save button
      modal.querySelector('#saveReorder').addEventListener('click', async () => {
        // Automatically assign sequential page numbers based on current order
        const newPageNumbers = pages.map((pg, idx) => idx + 1);
        
        // Update page numbers in pages array
        pages.forEach((pg, idx) => {
          pg.page_number = newPageNumbers[idx];
        });
        
        try {
          const response = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/reorder-pages`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'ngrok-skip-browser-warning': 'true'
            },
            body: JSON.stringify({ pages: pages.map((pg, idx) => ({ 
              page_number: idx + 1,  // Sequential numbering
              image_path: pg.image_path 
            }))})
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            alert('Failed to reorder pages: ' + (errorData.detail || 'Unknown error'));
            return;
          }
          
          modal.remove();
          await fetchSummary();
          alert('Pages reordered successfully!');
        } catch (error) {
          console.error('Reorder error:', error);
          alert('Failed to reorder pages: ' + error.message);
        }
      });
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }
    
    document.getElementById('saveAll').addEventListener('click', async ()=>{
      const pg = pages[currentIndex];
      if(!pg) return;
      const root = document.getElementById('panelsRoot');
      const tas = root.querySelectorAll('textarea[data-idx]');
      for(const ta of tas){
        const idx = parseInt(ta.getAttribute('data-idx'))||1;
        const text = (ta.value||'').trim();
        await savePanelText(pg.page_number, idx, text);
      }
      alert('Saved');
    });

    // Global: synthesize audio for pages that are missing audio
    document.getElementById('synthAll').addEventListener('click', async (e)=>{
      const btn = e.currentTarget;
      // Determine pages that have at least one panel missing audio
      const pagesToProcess = (pages || []).filter(pg => {
        const panels = pg.panels || [];
        return panels.some(p => !p.audio);
      });

      if(!pagesToProcess || pagesToProcess.length === 0){
        alert('All pages already have audio — nothing to synthesize.');
        return;
      }

      // Show which pages will be processed and confirm with the user
      const pageNums = pagesToProcess.map(p => p.page_number).sort((a,b)=>a-b);
      const confirmMsg = `This will synthesize audio for ${pageNums.length} page(s): ${pageNums.join(', ')}\n\nProceed?`;
      if(!confirm(confirmMsg)) return;

      btn.disabled = true; const original = btn.textContent; btn.textContent = 'Synthesizing…';
      const progressEl = document.getElementById('synthProgress');
      const barWrap = document.getElementById('synthBarWrap');
      const bar = document.getElementById('synthBar');
      barWrap.style.display = 'block';
      progressEl.textContent = 'Starting…'; bar.style.width = '0%';

      try{
        const totalPages = pagesToProcess.length;
        let pagesDone = 0;

        for(const pg of pagesToProcess){
          const pn = pg.page_number;
          progressEl.textContent = `Synthesizing Page ${pn}…`;
          const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/tts/synthesize/page/${encodeURIComponent(pn)}`, { method:'POST', headers:{'ngrok-skip-browser-warning':'true'} });
          if(!r.ok){
            console.warn('Page synth failed', pn, r.status);
          }else{
            const data = await r.json();
            const resPanels = (data && data.panels) || [];
            resPanels.forEach(item=>{
              if(item && item.audio_url){
                renderAudioFor(item.panel_index, item.audio_url);
                // patch local model: find the page object and update its panel
                const pgLocal = pages.find(x => parseInt(x.page_number) === parseInt(pn));
                if(pgLocal && Array.isArray(pgLocal.panels)){
                  const pLoc = pgLocal.panels.find(x=>parseInt(x.index)===parseInt(item.panel_index));
                  if(pLoc){ pLoc.audio = item.audio_url; }
                }
              }
            });
          }

          pagesDone++;
          const pct = Math.round((pagesDone/Math.max(1,totalPages))*100);
          bar.style.width = pct + '%';
          progressEl.textContent = `Completed ${pagesDone}/${totalPages} pages`;

          // If user is viewing a page we updated, re-render to reflect updates in selects/audio
          const currentPageNumber = (pages[currentIndex]||{}).page_number;
          if(currentPageNumber && pageNums.includes(currentPageNumber)){ renderCurrentPage(); }
        }

        progressEl.textContent = 'All done';
      }catch(err){
        console.error(err);
        progressEl.textContent = 'Error during synthesis';
        alert('Failed to synthesize.');
      }finally{
        btn.disabled = false; btn.textContent = original;
        setTimeout(()=>{ barWrap.style.display='none'; progressEl.textContent=''; bar.style.width='0%'; }, 1500);
      }
    });

    fetchSummary().catch(err=>{ console.error(err); alert('Failed to load project'); });

    // ---------- Helpers: TTS synth, upload, save, render ----------
    function audioSrcFromValue(val){
      if(!val) return '';
      if(typeof val !== 'string') return '';
      const v = val.trim();
      if(v.startsWith('http') || v.startsWith('/uploads/') || v.startsWith('/manga_projects/')) return v;
      if(v.startsWith('data:')) return v;
      // bare filename or relative uploads
      if(/\.(wav|mp3|ogg|m4a)$/i.test(v)){
        return v.startsWith('/uploads/') ? v : ('/uploads/' + v.replace(/^\/+/,''));
      }
      // assume base64 without data: prefix
      if(/^[A-Za-z0-9+/=]+$/.test(v)) return 'data:audio/wav;base64,'+v;
      return v;
    }

    function renderAudioFor(panelIndex, audioVal){
      const slot = document.querySelector(`.audio-slot[data-audio="${panelIndex}"]`);
      if(!slot) return;
      const src = audioSrcFromValue(audioVal);
      if(!src){ slot.innerHTML = ''; return; }
      slot.innerHTML = `<audio controls preload="metadata" src="${src}"></audio>`;
    }

    // Old direct TTS-by-text removed in favor of backend page synthesis

    async function uploadAudioBlob(blob, filename){
      const fd = new FormData();
      const file = new File([blob], filename, { type: 'audio/wav' });
      fd.append('files', file);
      const resp = await fetch('/upload', { method:'POST', body: fd });
      if(!resp.ok) throw new Error('Upload failed');
      const data = await resp.json();
      const name = (data.filenames && data.filenames[0]) ? data.filenames[0] : filename;
      return `/uploads/${name}`;
    }

    async function savePanelAudio(pageNumber, panelIndex, audioUrl){
      const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/panel/${encodeURIComponent(pageNumber)}/${encodeURIComponent(panelIndex)}/audio`, {
        method:'PUT', headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'},
        body: JSON.stringify({ audioUrl })
      });
      return r.ok;
    }

    // Synthesize a single panel via backend and return the audio URL (or null)
    async function synthPanel(projectId, pageNumber, panelIndex){
      // The server currently exposes a per-page synth endpoint. Call it and extract
      // the audio for the requested panel index instead of calling a non-existing
      // per-panel route (which returned 405).
      const resp = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/tts/synthesize/page/${encodeURIComponent(pageNumber)}`, {
        method: 'POST', headers: {'ngrok-skip-browser-warning':'true'}
      });
      if(!resp.ok){
        console.warn('Page synth failed when synthesizing single panel', pageNumber, panelIndex, resp.status);
        return null;
      }
      const data = await resp.json().catch(()=>null);
      if(!data) return null;
      // Response shape used elsewhere: { panels: [{ panel_index, audio_url }, ...] }
      if(Array.isArray(data.panels)){
        const item = data.panels.find(it => parseInt(it.panel_index)===parseInt(panelIndex));
        if(item && item.audio_url) return item.audio_url;
      }
      // Some backends may return a single object for the panel
      if(data.panel && parseInt(data.panel.panel_index)===parseInt(panelIndex) && data.panel.audio_url) return data.panel.audio_url;
      // Or maybe return { panel_index: X, audio_url: '...' }
      if(parseInt(data.panel_index)===parseInt(panelIndex) && data.audio_url) return data.audio_url;
      return null;
    }

    async function savePanelConfig(pageNumber, panelIndex, effect, transition){
      const r = await fetch(`/editor/api/project/${encodeURIComponent(project.id)}/panel/${encodeURIComponent(pageNumber)}/${encodeURIComponent(panelIndex)}/config`, {
        method:'PUT', headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'},
        body: JSON.stringify({ effect, transition })
      });
      return r.ok;
    }

    // Apply global config to ALL pages
    document.getElementById('applyGlobalConfig').addEventListener('click', async (e)=>{
      const btn = e.currentTarget || document.getElementById('applyGlobalConfig');
  const eff = document.getElementById('globalEffect').value || 'zoom_in';
      const trans = document.getElementById('globalTransition').value || 'slide_book';
      if(!pages || pages.length === 0) return;

      // UI feedback
      const original = btn.textContent;
      btn.disabled = true; btn.textContent = 'Applying…';
      try{
        // Apply on server for each page in parallel
        const results = await Promise.allSettled(
          pages.map(pg => fetch(`/editor/api/project/${encodeURIComponent(project.id)}/page/${encodeURIComponent(pg.page_number)}/config`, {
            method:'PUT',
            headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'},
            body: JSON.stringify({ effect: eff, transition: trans })
          }))
        );

        const allOk = results.every(r => r.status === 'fulfilled' && r.value && r.value.ok);

        // Update local model for all pages regardless; server failures will be alerted
        pages.forEach(pg => {
          (pg.panels || []).forEach(p => { p.effect = eff; p.transition = trans; });
        });

        // Re-render current page to reflect new selects immediately
        renderCurrentPage();

        if(allOk){
          alert('Applied to all pages');
        }else{
          const failed = results.filter(r => !(r.status === 'fulfilled' && r.value && r.value.ok)).length;
          alert(`Applied with ${failed} page(s) failing on server. Please retry.`);
        }
      }catch(err){
        console.error(err);
        alert('Failed to apply config');
      }finally{
        btn.disabled = false; btn.textContent = original;
      }
    });


    // ---------------- Model Management ----------------
    const modelStatusEl = document.getElementById('modelStatus');
    const loadModelBtn = document.getElementById('loadModelBtn');
    let modelCheckInterval = null;

    async function checkModelStatus() {
      try {
        const r = await fetch('/api/model/status');
        if (r.ok) {
          const status = await r.json();
          updateModelUI(status);
        }
      } catch (e) {
        console.warn('Failed to check model status', e);
        if(modelStatusEl) modelStatusEl.textContent = 'Model: Error';
      }
    }

    function updateModelUI(status) {
      if(!modelStatusEl || !loadModelBtn) return;
      if (status.loading) {
        modelStatusEl.textContent = 'Model: Loading...';
        loadModelBtn.style.display = 'none';
        if (!modelCheckInterval) startPolling(2000);
      } else if (status.loaded) {
        modelStatusEl.textContent = `Model: Loaded (${status.device})`;
        loadModelBtn.style.display = 'none';
        stopPolling(); 
      } else {
        modelStatusEl.textContent = 'Model: Not Loaded';
        loadModelBtn.style.display = 'inline-block';
        stopPolling();
      }
    }

    function startPolling(ms) {
      stopPolling();
      modelCheckInterval = setInterval(checkModelStatus, ms);
    }

    function stopPolling() {
      if (modelCheckInterval) {
        clearInterval(modelCheckInterval);
        modelCheckInterval = null;
      }
    }

    if(loadModelBtn){
        loadModelBtn.addEventListener('click', async () => {
          loadModelBtn.disabled = true;
          loadModelBtn.textContent = 'Loading...';
          try {
            const r = await fetch('/api/model/load', { method: 'POST' });
            const data = await r.json();
            if (data.status === 'loading' || data.status === 'loaded') {
              startPolling(2000); 
            } else {
              alert('Failed to trigger model load: ' + (data.message || 'Unknown error'));
              loadModelBtn.disabled = false;
              loadModelBtn.textContent = 'Load Model';
            }
          } catch (e) {
            console.error(e);
            alert('Error loading model');
            loadModelBtn.disabled = false;
            loadModelBtn.textContent = 'Load Model';
          }
        });
    }

    // Check status on load
    checkModelStatus();
  </script>
</body>
</html>