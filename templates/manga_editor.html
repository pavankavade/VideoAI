<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manga Editor ‚Äì {{ project.title }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/ui.build.css?v=1" />
  <style>
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif}
    .wrap{max-width:1200px;margin:0 auto;padding:20px}
    .topbar{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
    .h1{font-weight:800;font-size:22px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    /* Cards and buttons use shared styles */
    .status{font-size:12px;color:#94a3b8}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    .page{background:#0b1220;border:1px solid #1e293b;border-radius:12px;padding:12px;margin-bottom:12px}
    .page h4{margin:0 0 8px 0}
    .panels{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px}
    .panel{border:1px solid #1f2937;border-radius:8px;overflow:hidden;background:#0a1322}
    .panel img{display:block;width:100%;height:140px;object-fit:cover}
    .panel .meta{padding:8px;font-size:12px;color:#94a3b8}
    .nav{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;color:#9fb}
    .pill{display:inline-flex;align-items:center;gap:8px;background:#0b1220;border:1px solid #1e293b;padding:6px 10px;border-radius:999px;color:#cbd5e1}
    .list{display:flex;gap:8px;flex-wrap:wrap}
    /* Simple spinner for narration progress */
    .loading{width:16px;height:16px;border:2px solid rgba(59,130,246,.25);border-top-color:#3b82f6;border-radius:50%;display:inline-block;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{to{transform:rotate(360deg)}}
    .progress-row{display:flex;align-items:center;gap:10px;margin-top:8px;color:#94a3b8;font-size:13px}
    .progress-row.hidden{display:none}
    .bar-wrap{flex:1;height:6px;background:#0b172d;border:1px solid #1e293b;border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0%;background:#3b82f6;transition:width .2s}
    .row-progress{display:flex;align-items:center;gap:10px;margin-top:8px}
    /* Page spacing improvements */
    #gating{margin-bottom:16px}
    .card-pad{padding:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="h1">Manga Editor ‚Äì {{ project.title }}</div>
      <div class="row">
        <a class="btn secondary" href="/">Back</a>
      </div>
    </div>

    <div id="gating" class="card">
      <div class="card-pad" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div>
          <div style="font-weight:700">Preparation</div>
          <div class="status" id="prepStatus">Checking panel status‚Ä¶</div>
        </div>
        <div class="row">
          <button id="btnCreatePanels" class="btn">Create Panels</button>
          <button id="btnOpenViewer" class="btn" disabled>View Panels</button>
        </div>
      </div>
    </div>

    <div class="grid">
      <div>
        <div class="card">
          <div class="card-pad">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;margin-bottom:8px">
            <div>
              <div style="font-weight:700">Narration</div>
              <div class="status">Generate a sentence per panel, sequentially by page.</div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <span style="font-size:12px;color:#94a3b8">Provider:</span>
              <select id="narratorProvider" class="select" style="padding:4px 8px;font-size:12px;width:auto">
                  <option value="gemini" {% if project.narration_provider == 'gemini' %}selected{% endif %}>Gemini</option>
                  <option value="groq" {% if project.narration_provider == 'groq' %}selected{% endif %}>Groq</option>
                  <option value="azure" {% if project.narration_provider == 'azure' %}selected{% endif %}>Azure OpenAI</option>
              </select>
            </div>
            <div class="row">
              <button id="btnNarrateSequential" class="btn">Create Narration (All)</button>
              <button id="btnContinueNarration" class="btn" style="background:#10b981">Continue Narration</button>
              <button id="btnRedoNarration" class="btn secondary" title="Overwrite existing narration">Redo Narration</button>
              <button id="btnNarratePage" class="btn secondary">Narrate Current Page</button>
            </div>
          </div>
          <div id="narrationProgress" class="progress-row hidden">
            <span class="loading"></span>
            <span id="narrationProgressText">Working‚Ä¶</span>
            <div class="bar-wrap"><div id="narrationBar" class="bar"></div></div>
          </div>
          <div id="panelsProgress" class="progress-row hidden">
            <span class="loading"></span>
            <span id="panelsProgressText">Detecting panels‚Ä¶</span>
            <div class="bar-wrap"><div id="panelsBar" class="bar"></div></div>
          </div>
          <div id="pagesRoot"></div>
          </div>
        </div>
      </div>
      <div>
        <div class="card">
          <div class="card-pad">
          <div style="font-weight:700;margin-bottom:8px">Character List (Markdown)</div>
          <textarea id="characterMd" class="textarea" placeholder="- Character Name: appearance notes\n- ‚Ä¶"></textarea>
          <div class="nav">
            <div class="status">‚ö†Ô∏è Manual update required: Edit character list as you narrate, then click Save.</div>
            <div class="row">
              <button id="btnSaveCharacters" class="btn">üíæ Save Character List</button>
              <button id="btnAutoCharacters" class="btn secondary">Auto Update From Narration</button>
            </div>
          </div>
          </div>
        </div>

        <!-- Story So Far from Previous Chapters -->
        <div class="card">
          <div class="card-pad">
          <div style="font-weight:700;margin-bottom:8px">Story So Far (Previous Chapters)</div>
          <textarea id="storySummaryPrevious" class="textarea" placeholder="Summaries from previous chapters will appear here. Click 'Fetch Previous Chapters' to load..." readonly style="background:rgba(11,23,45,0.3);cursor:not-allowed"></textarea>
          <div class="nav">
            <div class="status">Read-only: Fetched from previous chapters' summaries.</div>
            <div class="row">
              <button id="btnFetchPrevious" class="btn">Fetch Previous Chapters</button>
            </div>
          </div>
          </div>
        </div>

        <!-- Current Chapter Summary -->
        <div class="card">
          <div class="card-pad">
          <div style="font-weight:700;margin-bottom:8px">Current Chapter Summary</div>
          <textarea id="storySummaryCurrent" class="textarea" placeholder="Auto-generated after narration completes. You can also edit manually..."></textarea>
          <div class="nav">
            <div class="status">‚ú® Auto-generated after narration completion. Manual editing optional.</div>
            <div class="row">
              <button id="btnSaveStory" class="btn secondary">Save Manual Edits</button>
              <button id="btnGenerateStory" class="btn secondary">Re-generate Summary</button>
            </div>
          </div>
          </div>
        </div>

        <div class="card">
          <div class="card-pad">
          <div style="font-weight:700;margin-bottom:8px">Shortcuts</div>
          <div class="list">
            <span class="pill"><span class="kbd">All</span> Create narration for all pages</span>
            <span class="pill"><span class="kbd">Page</span> Narrate only the current page</span>
            <span class="pill"><span class="kbd">Panels</span> Ensure panels exist before narrating</span>
          </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script id="project-data" type="application/json">{{ project|tojson|safe }}</script>
  <script>
    const project = JSON.parse(document.getElementById('project-data')?.textContent || '{}');
    const projectId = project.id;
    let pages = [];
    let allPanelsReady = false;
    let currentPageIndex = 0;

    async function fetchSummary(){
      const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}`, { headers: { 'ngrok-skip-browser-warning':'true' } });
      if(!r.ok) throw new Error('Failed to load project');
      const d = await r.json();
      pages = d.pages || [];
      allPanelsReady = !!d.allPanelsReady;
      document.getElementById('characterMd').value = d.characterList || '';
      
      // Load story summaries
      await loadStorySummaries();
      
      renderGating();
      renderPages();
    }

    async function loadStorySummaries(){
      try{
        const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/story`);
        if(!r.ok) return;
        const d = await r.json();
        document.getElementById('storySummaryCurrent').value = d.summary_current || d.summary || '';
        document.getElementById('storySummaryPrevious').value = d.summary_previous || '';
      }catch(e){
        console.error('Failed to load story summaries:', e);
      }
    }

    function renderGating(){
      const st = document.getElementById('prepStatus');
      const btnCreate = document.getElementById('btnCreatePanels');
      const btnView = document.getElementById('btnOpenViewer');
      if(allPanelsReady){
        st.textContent = 'All pages have panels. You can view and narrate.';
        btnView.disabled = false;
      }else{
        st.textContent = 'Panels missing. Generate them before viewing.';
        btnView.disabled = true;
      }
    }
    function setPanelsBusy(isBusy, msg, pct){
      const pr = document.getElementById('panelsProgress');
      const txt = document.getElementById('panelsProgressText');
      const bar = document.getElementById('panelsBar');
      const bCreate = document.getElementById('btnCreatePanels');
      const bView = document.getElementById('btnOpenViewer');
      if(isBusy){
        if(txt) txt.textContent = msg || 'Detecting panels‚Ä¶';
        pr?.classList.remove('hidden');
        bCreate.disabled = true; bView.disabled = true;
        if(typeof pct === 'number' && bar){ bar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
      }else{
        pr?.classList.add('hidden');
        bCreate.disabled = false; bView.disabled = !allPanelsReady;
        if(bar){ bar.style.width = '0%'; }
      }
    }

    async function createPanelsWithProgress(){
      // Build page list from summary
      const pagesToProcess = (pages||[]);
      if(!pagesToProcess.length){ alert('No pages to process'); return; }
      setPanelsBusy(true, `Starting panel detection for ${pagesToProcess.length} page(s)‚Ä¶`, 0);
      for(let i=0;i<pagesToProcess.length;i++){
        const pg = pagesToProcess[i];
        const label = `Page ${i+1}/${pagesToProcess.length} (Page ${pg.page_number})‚Ä¶`;
        setPanelsBusy(true, label, (i/pagesToProcess.length)*100);
        try{
          const resp = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/panels/create/page/${encodeURIComponent(pg.page_number)}`, { method:'POST', headers:{'ngrok-skip-browser-warning':'true'} });
          if(!resp.ok){ throw new Error(`Panels failed for page ${pg.page_number}`); }
        }catch(e){
          setPanelsBusy(false);
          alert((e && e.message) || 'Panel creation failed');
          return;
        }
      }
      setPanelsBusy(true, 'Finalizing‚Ä¶', 100);
      await fetchSummary();
      setPanelsBusy(false);
      renderGating();
    }

    function renderPages(){
      const root = document.getElementById('pagesRoot');
      root.innerHTML = '';
      pages.forEach((pg, i)=>{
        const div = document.createElement('div');
        div.className = 'page';
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:6px">
            <h4>Page ${pg.page_number}</h4>
            <div class="row">
              <button class="btn secondary" data-redo="${i}" title="Retry narration for this page">Retry</button>
              <button class="btn secondary" data-go="${i}">Go</button>
            </div>
          </div>
          <div class="panels">
            ${(pg.panels||[]).map(p => `
              <div class="panel">
                ${p.image ? `<img src="${p.image}?t=${Date.now()}" alt="panel"/>` : `<div style='height:140px;display:flex;align-items:center;justify-content:center;color:#94a3b8'>No image</div>`}
                <div class="meta">#${p.index} ${p.text ? ('‚Äì ' + p.text) : ''}</div>
              </div>
            `).join('')}
          </div>
        `;
        root.appendChild(div);
      });

      root.querySelectorAll('button[data-go]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          currentPageIndex = parseInt(btn.getAttribute('data-go'))||0;
          document.getElementById('btnNarratePage').scrollIntoView({behavior:'smooth', block:'center'});
        });
      });
      
      root.querySelectorAll('button[data-redo]').forEach(btn=>{
        btn.addEventListener('click', async (e)=>{
          const idx = parseInt(btn.getAttribute('data-redo'))||0;
          // No confirmation needed per user request
          
          btn.disabled = true;
          const origText = btn.textContent;
          btn.textContent = '...';
          await narrateSinglePage(idx);
          btn.disabled = false;
          btn.textContent = origText;
        });
      });
    }

    function setNarrationBusy(isBusy, msg, pct){
      const pr = document.getElementById('narrationProgress');
      const txt = document.getElementById('narrationProgressText');
      const bar = document.getElementById('narrationBar');
      const bAll = document.getElementById('btnNarrateSequential');
      const bRedo = document.getElementById('btnRedoNarration');
      const bPage = document.getElementById('btnNarratePage');
      if(isBusy){
        if(txt) txt.textContent = msg || 'Generating narration‚Ä¶';
        pr?.classList.remove('hidden');
        bAll.disabled = true; bRedo.disabled = true; bPage.disabled = true;
        if(typeof pct === 'number' && bar){ bar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
      }else{
        pr?.classList.add('hidden');
        bAll.disabled = false; bRedo.disabled = false; bPage.disabled = false;
        if(bar){ bar.style.width = '0%'; }
      }
    }

    async function narrateAll(redo=false, skipExisting=false){
      const mdEl = document.getElementById('characterMd');
      const characterList = mdEl.value || '';
      // Only pages that have panels
      let pagesWithPanels = (pages||[]).filter(pg => (pg.panels||[]).length > 0);
      
      // If skipExisting, filter out pages that already have narration
      if (skipExisting) {
        pagesWithPanels = pagesWithPanels.filter(pg => {
          const hasNarration = (pg.panels||[]).some(p => p.text && p.text.trim().length > 0);
          return !hasNarration;
        });
      }
      
      const total = pagesWithPanels.length;
      if(total === 0){ 
        if (skipExisting) {
          alert('All pages already have narration!'); 
        } else {
          alert('No panels found. Create panels first.'); 
        }
        return; 
      }

      let accumulated = '';
      setNarrationBusy(true, `Starting narration for ${total} page(s)‚Ä¶`, 0);
      
      for(let i=0;i<total;i++){
        const pg = pagesWithPanels[i];
        const label = `Page ${i+1}/${total} (Page ${pg.page_number})‚Ä¶`;
        setNarrationBusy(true, label, (i/total)*100);
        try{
          const resp = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/narrate/page/${encodeURIComponent(pg.page_number)}`, {
            method:'POST', headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'},
            body: JSON.stringify({ characterList, context: accumulated })
          });
          
          if(!resp.ok){ 
            // Check if it's a blocked content error
            const errorData = await resp.json().catch(() => null);
            if (errorData && errorData.detail && typeof errorData.detail === 'object' && errorData.detail.error === 'blocked') {
              // Show blocked content UI
              setNarrationBusy(false);
              await showBlockedContentUI(pg.page_number, errorData.detail);
              return; // Stop the batch narration
            }
            throw new Error(`Narration failed for page ${pg.page_number}`); 
          }
          
          const data = await resp.json();
          const items = (data && Array.isArray(data.panels)) ? data.panels : [];
          // Build context like server does
          const ctxSeg = items.map(it => `[${it.panel_index}] ${it.text||''}`.trim()).join('; ');
          accumulated += `\nPage ${pg.page_number}: ${ctxSeg}`;
        }catch(e){
          setNarrationBusy(false);
          alert((e && e.message) || 'Narration failed');
          return;
        }
      }
      setNarrationBusy(true, 'Finalizing‚Ä¶', 100);
      
      // Reload data to get updated narrations
      await fetchSummary();
      
      // Automatically generate story summary after narration is complete
      setNarrationBusy(true, 'Generating story summary‚Ä¶', 100);
      try {
        const summaryResp = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/story/generate`, { 
          method:'POST', 
          headers:{'ngrok-skip-browser-warning':'true'} 
        });
        if (summaryResp.ok) {
          const summaryData = await summaryResp.json();
          document.getElementById('storySummaryCurrent').value = summaryData.summary || '';
        }
      } catch(e) {
        console.error('Story summary generation failed:', e);
        // Don't fail the whole process if summary generation fails
      }
      
      setNarrationBusy(false);
      
      // Show completion message with prompt to update character list
      let completionMsg = '';
      if(redo) {
        completionMsg = 'Narration updated and story summary generated!\n\nDon\'t forget to update the Character List if needed.';
      } else if(skipExisting) {
        completionMsg = 'Continued narration complete and story summary generated!\n\nDon\'t forget to update the Character List if needed.';
      } else {
        completionMsg = 'Narration complete and story summary generated!\n\nDon\'t forget to update the Character List manually.';
      }
      alert(completionMsg);
    }

    async function showBlockedContentUI(pageNumber, errorDetail) {
      const prompt = errorDetail.prompt || 'Could not extract prompt';
      const message = errorDetail.message || 'Content was blocked';
      const blockReason = errorDetail.block_reason || 'UNKNOWN';
      
      // Find the page
      const pageIdx = pages.findIndex(p => p.page_number === pageNumber);
      if (pageIdx === -1) return;
      
      currentPageIndex = pageIdx;
      renderPages();
      
      // Get panel count for this page
      const pg = pages[pageIdx];
      const panelCount = (pg.panels || []).length;

      // Collect Story So Far
      let storySoFar = '';
      for (let i = 0; i < pageIdx; i++) {
        const p = pages[i];
        if (p.panels) {
           p.panels.forEach(panel => {
             if (panel.text) storySoFar += `[Page ${p.page_number} Panel ${panel.panel_index}]: ${panel.text}\n`;
           });
        }
      }
      if (!storySoFar) storySoFar = '(No previous narration)';

      // Generate Panels HTML
      let panelsHtml = '';
      if (pg.panels && pg.panels.length > 0) {
        panelsHtml = '<div style="display:flex;overflow-x:auto;gap:10px;padding-bottom:10px;margin-bottom:10px">';
        pg.panels.forEach(p => {
           panelsHtml += `
             <div style="flex:0 0 auto;width:200px;">
               <img src="${p.image}?t=${Date.now()}" style="width:100%;height:auto;border-radius:4px;border:1px solid #334155;display:block">
               <div style="font-size:12px;color:#94a3b8;text-align:center;margin-top:4px;background:#1e293b;padding:2px;border-radius:4px">Panel ${p.panel_index}</div>
             </div>
           `;
        });
        panelsHtml += '</div>';
      } else {
        panelsHtml = '<p style="color:#94a3b8;font-style:italic">No panels found for this page.</p>';
      }
      
      // Create a modal/dialog for blocked content
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:1000;display:flex;align-items:center;justify-content:center;padding:20px';
      modal.innerHTML = `
        <div class="card" style="max-width:1000px;width:100%;max-height:95vh;overflow:hidden;display:flex;flex-direction:column">
          <div class="card-pad" style="overflow-y:auto;flex:1">
            <h2 style="color:#ef4444;margin-bottom:16px">‚ö†Ô∏è Content Blocked for Page ${pageNumber}</h2>
            <p style="margin-bottom:16px;color:#94a3b8">${message}</p>
            
            <div style="display:grid;grid-template-columns: 1fr 1fr;gap:20px;margin-bottom:20px">
                <div>
                    <strong style="display:block;margin-bottom:8px">Story So Far:</strong>
                    <textarea readonly class="textarea" style="height:150px;font-size:12px;background:#0b1220;color:#cbd5e1">${storySoFar}</textarea>
                </div>
                 <div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                        <strong>System Prompt:</strong>
                        <button id="copyPromptBtn" class="btn secondary" style="padding:2px 8px;font-size:11px">Copy</button>
                    </div>
                    <textarea readonly class="textarea" style="height:150px;font-family:monospace;font-size:12px;background:#0b1220;color:#cbd5e1">${prompt}</textarea>
                </div>
            </div>

            <div style="margin-bottom:20px">
                <strong style="display:block;margin-bottom:8px">Current Panels:</strong>
                ${panelsHtml}
            </div>
            
            <div style="margin-bottom:16px;background:#1e293b;padding:16px;border-radius:8px">
              <strong style="display:block;margin-bottom:8px;color:#fff">Manual Narration Entry:</strong>
              <p style="color:#94a3b8;margin:4px 0 12px 0;font-size:14px">Paste JSON format from AI or enter line-by-line. <strong>Panel count: ${panelCount}</strong></p>
              <div style="margin-bottom:12px">
                <label style="display:inline-flex;align-items:center;gap:8px;color:#cbd5e1;font-size:14px;margin-right:16px">
                  <input type="radio" name="narrationFormat" value="json" checked style="margin:0">
                  JSON Format
                </label>
                <label style="display:inline-flex;align-items:center;gap:8px;color:#cbd5e1;font-size:14px">
                  <input type="radio" name="narrationFormat" value="lines" style="margin:0">
                  Line-by-line
                </label>
              </div>
              <textarea id="manualNarrationInput" class="textarea" placeholder='JSON Format (panel_index: 1, 2, 3...):
{
  "panels": [
    {
      "panel_index": 1,
      "text": "Your narration here"
    }
  ]
}

OR Line-by-line (auto-numbered 1, 2, 3...):
Panel 1 narration
Panel 2 narration' style="min-height:200px;font-family:monospace;font-size:14px;background:#0f172a;border:1px solid #334155"></textarea>
            </div>
            
            <div class="row" style="justify-content:flex-end;gap:8px;margin-top:16px">
              <button id="cancelBlockedBtn" class="btn secondary">Cancel</button>
              <button id="saveManualNarrationBtn" class="btn primary">Save Manual Narration</button>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Copy prompt button
      modal.querySelector('#copyPromptBtn').addEventListener('click', () => {
        navigator.clipboard.writeText(prompt).then(() => {
          alert('Prompt copied to clipboard!');
        }).catch(err => {
          console.error('Failed to copy:', err);
          alert('Failed to copy prompt');
        });
      });
      
      // Cancel button
      modal.querySelector('#cancelBlockedBtn').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Save manual narration button
      modal.querySelector('#saveManualNarrationBtn').addEventListener('click', async () => {
        const manualText = modal.querySelector('#manualNarrationInput').value.trim();
        if (!manualText) {
          alert('Please enter narration text');
          return;
        }
        
        const pg = pages[pageIdx];
        const panelCount = (pg.panels || []).length;
        let panelsData = [];
        
        // Check which format is selected
        const formatRadio = modal.querySelector('input[name="narrationFormat"]:checked');
        const format = formatRadio ? formatRadio.value : 'json';
        
        if (format === 'json') {
          // Try to parse as JSON first
          try {
            const parsed = JSON.parse(manualText);
            
            // Check if it has the expected structure
            if (parsed.panels && Array.isArray(parsed.panels)) {
              panelsData = parsed.panels.map(p => ({
                panel_index: parseInt(p.panel_index) || 0,
                text: String(p.text || '').trim()
              })).filter(p => p.text && p.panel_index > 0);
            } else {
              throw new Error('JSON must have a "panels" array');
            }
          } catch (e) {
            alert('Invalid JSON format. Please check the structure:\n{\n  "panels": [\n    {"panel_index": 1, "text": "..."},\n    {"panel_index": 2, "text": "..."}\n  ]\n}\n\nError: ' + e.message);
            return;
          }
        } else {
          // Line-by-line format
          const lines = manualText.split('\n').filter(l => l.trim());
          for (let i = 0; i < Math.min(lines.length, panelCount); i++) {
            panelsData.push({
              panel_index: i + 1,
              text: lines[i].trim()
            });
          }
        }
        
        if (panelsData.length === 0) {
          alert('No valid narration data found');
          return;
        }
        
        // Validate panel indices
        const maxIndex = Math.max(...panelsData.map(p => p.panel_index));
        if (maxIndex > panelCount) {
          if (!confirm(`Warning: You have panel_index ${maxIndex} but only ${panelCount} panels exist. Continue anyway?`)) {
            return;
          }
        }
        
        // Save to backend
        try {
          const resp = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/narrate/page/${pageNumber}/manual`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true'},
            body: JSON.stringify({ panels: panelsData })
          });
          
          if (!resp.ok) {
            throw new Error('Failed to save manual narration');
          }
          
          document.body.removeChild(modal);
          await fetchSummary();
          alert(`Manual narration saved for page ${pageNumber}! (${panelsData.length} panels updated)`);
        } catch (err) {
          console.error(err);
          alert('Failed to save manual narration: ' + err.message);
        }
      });
    }

    document.getElementById('btnCreatePanels').addEventListener('click', async ()=>{
      if(!confirm('Create panels for all pages now?')) return;
      await createPanelsWithProgress();
    });

    document.getElementById('btnOpenViewer').addEventListener('click', ()=>{
      // Open the new full-page panel editor
      window.location.href = `/editor/panel-editor/${encodeURIComponent(projectId)}`;
    });

    document.getElementById('btnNarrateSequential').addEventListener('click', async ()=>{
      narrateAll(false, false);
    });

    document.getElementById('btnContinueNarration').addEventListener('click', async ()=>{
      narrateAll(false, true);
    });

    document.getElementById('btnRedoNarration').addEventListener('click', async ()=>{
      if(!confirm('This will overwrite existing panel narrations. Continue?')) return;
      narrateAll(true, false);
    });

    async function narrateSinglePage(idx) {
      if(!pages.length || !pages[idx]){ alert('Page not found'); return; }
      const pg = pages[idx];
      const characterList = document.getElementById('characterMd').value || '';
      
      // Build context from previous pages
      let context = '';
      for(let i=0; i<idx; i++){
        const prevPg = pages[i];
        if(prevPg.panels && prevPg.panels.length > 0){
             const ctxSeg = prevPg.panels.map(it => `[${it.panel_index}] ${it.text||''}`.trim()).join('; ');
             context += `\nPage ${prevPg.page_number}: ${ctxSeg}`;
        }
      }

      setNarrationBusy(true, `Generating narration for page ${pg.page_number}‚Ä¶`, 0);
      
      try {
        const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/narrate/page/${encodeURIComponent(pg.page_number)}`, { 
          method:'POST', 
          headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'}, 
          body: JSON.stringify({ characterList, context }) 
        });
        
        if(!r.ok){ 
          const errorData = await r.json().catch(() => null);
          if (errorData && errorData.detail && typeof errorData.detail === 'object' && errorData.detail.error === 'blocked') {
            setNarrationBusy(false);
            await showBlockedContentUI(pg.page_number, errorData.detail);
            return;
          }
          setNarrationBusy(false); 
          alert('Narration failed'); 
          return; 
        }
        
        await fetchSummary();
        setNarrationBusy(false);
      } catch(e) {
        setNarrationBusy(false);
        alert('Narration failed: ' + (e.message || 'Unknown error'));
      }
    }

    document.getElementById('btnNarratePage').addEventListener('click', async ()=>{
      if(!pages.length){ alert('No pages loaded'); return; }
      await narrateSinglePage(currentPageIndex);
    });

    document.getElementById('btnSaveCharacters').addEventListener('click', async ()=>{
      const markdown = document.getElementById('characterMd').value || '';
      try {
        const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/characters`, { 
          method:'PUT', 
          headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'}, 
          body: JSON.stringify({ markdown }) 
        });
        if(!r.ok){ 
          const errData = await r.json().catch(() => ({}));
          alert('Save failed: ' + (errData.detail || 'Unknown error')); 
          return; 
        }
        const result = await r.json();
        
        // Show detailed message based on whether this is part of a series
        if (result.series_id && result.chapters_updated) {
          alert(`‚úÖ Character list saved successfully!\n\nüìö Propagated to ${result.chapters_updated} chapter(s) in this series.\n\nAll chapters now have the same character list.`);
        } else {
          alert('‚úÖ Character list saved successfully!');
        }
      } catch(e) {
        console.error('Character save error:', e);
        alert('Failed to save character list: ' + e.message);
      }
    });

    document.getElementById('btnAutoCharacters').addEventListener('click', async ()=>{
      const btn = document.getElementById('btnAutoCharacters');
      const origText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Updating...';
      try {
        const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/characters/update`, { 
          method:'POST', 
          headers:{'ngrok-skip-browser-warning':'true'} 
        });
        if(!r.ok){ 
          const errData = await r.json().catch(() => ({}));
          alert('Auto update failed: ' + (errData.detail || 'Unknown error')); 
          return; 
        }
        const d = await r.json();
        document.getElementById('characterMd').value = d.markdown || '';
        alert('Character list auto-updated from narrations!');
      } catch(e) {
        console.error('Character auto-update error:', e);
        alert('Failed to auto-update character list: ' + e.message);
      } finally {
        btn.disabled = false;
        btn.textContent = origText;
      }
    });

    document.getElementById('btnSaveStory').addEventListener('click', async ()=>{
      const summary = document.getElementById('storySummaryCurrent').value || '';
      const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/story`, { method:'PUT', headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'}, body: JSON.stringify({ summary }) });
      if(!r.ok){ alert('Save failed'); return; }
      alert('Current chapter summary saved');
    });

    document.getElementById('btnGenerateStory').addEventListener('click', async ()=>{
      if(!confirm('Generate a story summary for THIS CHAPTER from all panel narrations? This may take a moment.')) return;
      const btn = document.getElementById('btnGenerateStory');
      const origText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Generating...';
      try {
        const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/story/generate`, { method:'POST', headers:{'ngrok-skip-browser-warning':'true'} });
        if(!r.ok){ alert('Story generation failed'); return; }
        const d = await r.json();
        document.getElementById('storySummaryCurrent').value = d.summary || '';
        alert('Current chapter summary generated');
      } finally {
        btn.disabled = false;
        btn.textContent = origText;
      }
    });

    document.getElementById('btnFetchPrevious').addEventListener('click', async ()=>{
      if(!confirm('Fetch and combine all previous chapters\' summaries into the "Story So Far" section?')) return;
      const btn = document.getElementById('btnFetchPrevious');
      const origText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Fetching...';
      try {
        const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/story/fetch-previous`, { method:'POST', headers:{'ngrok-skip-browser-warning':'true'} });
        if(!r.ok){
          const errData = await r.json().catch(() => ({}));
          alert(errData.detail || 'Failed to fetch previous summaries');
          return;
        }
        const d = await r.json();
        document.getElementById('storySummaryPrevious').value = d.summary || '';
        alert(d.message || 'Previous chapters\' summaries fetched successfully');
      } finally {
        btn.disabled = false;
        btn.textContent = origText;
      }
    });

    fetchSummary().catch(err=>{ console.error(err); alert('Failed to load project'); });

    fetchSummary().catch(err=>{ console.error(err); alert('Failed to load project'); });
    
    // Provider Switcher Logic
    const narratorProviderSelect = document.getElementById('narratorProvider');
    if (narratorProviderSelect) {
        narratorProviderSelect.addEventListener('change', async (e) => {
            const newProvider = e.target.value;
            try {
                const r = await fetch(`/editor/api/project/${encodeURIComponent(projectId)}/settings/provider`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true'},
                    body: JSON.stringify({ provider: newProvider })
                });
                if (!r.ok) { throw new Error('Failed to update provider'); }
                // Optional: flash success
                console.log('Provider switched to', newProvider);
            } catch (err) {
                console.error(err);
                alert('Failed to switch provider: ' + err.message);
                // Revert
                // window.location.reload(); 
            }
        });
    }

    // Check for manual entry request from dashboard
    window.addEventListener('DOMContentLoaded', async () => {
      const params = new URLSearchParams(window.location.search);
      if (params.get('manual_entry') === 'true') {
        const pageNum = parseInt(params.get('page'));
        if (pageNum && !isNaN(pageNum)) {
          // Wait a moment for data to load
          setTimeout(async () => {
            console.log(`Auto-opening manual entry for page ${pageNum}`);
            // We need to simulate the error data structure expected by showBlockedContentUI
            const mockErrorDetail = {
              error: 'blocked',
              reason: 'Manual entry requested via dashboard',
              page: pageNum
            };
            await showBlockedContentUI(pageNum, mockErrorDetail);
          }, 1000);
        }
      }
    });
  </script>

  
</body>
</html>
